// Code generated by peg. DO NOT EDIT.
package parser

import (
	"fmt"
	"math"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleDocument
	ruleHeader
	ruleInclude
	ruleCppInclude
	ruleNamespace
	ruleNamespaceScope
	ruleDefinition
	ruleConst
	ruleTypedef
	ruleEnum
	ruleStruct
	ruleUnion
	ruleService
	ruleException
	ruleField
	ruleFieldId
	ruleFieldReq
	ruleFunction
	ruleFunctionType
	ruleThrows
	ruleFieldType
	ruleBaseType
	ruleContainerType
	ruleMapType
	ruleSetType
	ruleListType
	ruleCppType
	ruleConstValue
	ruleIntConstant
	ruleDoubleConstant
	ruleExponent
	ruleAnnotations
	ruleAnnotation
	ruleConstList
	ruleConstMap
	ruleEscapeLiteralChar
	ruleLiteral
	ruleIdentifier
	ruleListSeparator
	ruleLetter
	ruleLetterOrDigit
	ruleDigit
	ruleSkip
	ruleSpace
	ruleLongComment
	ruleLineComment
	ruleUnixComment
	ruleBOOL
	ruleBYTE
	ruleI8
	ruleI16
	ruleI32
	ruleI64
	ruleDOUBLE
	ruleSTRING
	ruleBINARY
	ruleCONST
	ruleONEWAY
	ruleTYPEDEF
	ruleMAP
	ruleSET
	ruleLIST
	ruleVOID
	ruleTHROWS
	ruleEXCEPTION
	ruleEXTENDS
	ruleSERVICE
	ruleSTRUCT
	ruleUNION
	ruleENUM
	ruleINCLUDE
	ruleCPPINCLUDE
	ruleNAMESPACE
	ruleCPPTYPE
	ruleLBRK
	ruleRBRK
	ruleLWING
	ruleRWING
	ruleEQUAL
	ruleLPOINT
	ruleRPOINT
	ruleCOMMA
	ruleLPAR
	ruleRPAR
	ruleCOLON
	rulePegText

	rulePre
	ruleIn
	ruleSuf
)

var rul3s = [...]string{
	"Unknown",
	"Document",
	"Header",
	"Include",
	"CppInclude",
	"Namespace",
	"NamespaceScope",
	"Definition",
	"Const",
	"Typedef",
	"Enum",
	"Struct",
	"Union",
	"Service",
	"Exception",
	"Field",
	"FieldId",
	"FieldReq",
	"Function",
	"FunctionType",
	"Throws",
	"FieldType",
	"BaseType",
	"ContainerType",
	"MapType",
	"SetType",
	"ListType",
	"CppType",
	"ConstValue",
	"IntConstant",
	"DoubleConstant",
	"Exponent",
	"Annotations",
	"Annotation",
	"ConstList",
	"ConstMap",
	"EscapeLiteralChar",
	"Literal",
	"Identifier",
	"ListSeparator",
	"Letter",
	"LetterOrDigit",
	"Digit",
	"Skip",
	"Space",
	"LongComment",
	"LineComment",
	"UnixComment",
	"BOOL",
	"BYTE",
	"I8",
	"I16",
	"I32",
	"I64",
	"DOUBLE",
	"STRING",
	"BINARY",
	"CONST",
	"ONEWAY",
	"TYPEDEF",
	"MAP",
	"SET",
	"LIST",
	"VOID",
	"THROWS",
	"EXCEPTION",
	"EXTENDS",
	"SERVICE",
	"STRUCT",
	"UNION",
	"ENUM",
	"INCLUDE",
	"CPPINCLUDE",
	"NAMESPACE",
	"CPPTYPE",
	"LBRK",
	"RBRK",
	"LWING",
	"RWING",
	"EQUAL",
	"LPOINT",
	"RPOINT",
	"COMMA",
	"LPAR",
	"RPAR",
	"COLON",
	"PegText",

	"Pre_",
	"_In_",
	"_Suf",
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(depth int, buffer string) {
	for node != nil {
		for c := 0; c < depth; c++ {
			fmt.Printf(" ")
		}
		fmt.Printf("\x1B[34m%v\x1B[m %v\n", rul3s[node.pegRule], strconv.Quote(string(([]rune(buffer)[node.begin:node.end]))))
		if node.up != nil {
			node.up.print(depth+1, buffer)
		}
		node = node.next
	}
}

func (node *node32) Print(buffer string) {
	node.print(0, buffer)
}

type element struct {
	node *node32
	down *element
}

/* ${@} bit structure for abstract syntax tree */
type token32 struct {
	pegRule
	begin, end, next uint32
}

func (t *token32) isZero() bool {
	return t.pegRule == ruleUnknown && t.begin == 0 && t.end == 0 && t.next == 0
}

func (t *token32) isParentOf(u token32) bool {
	return t.begin <= u.begin && t.end >= u.end && t.next > u.next
}

func (t *token32) getToken32() token32 {
	return token32{pegRule: t.pegRule, begin: uint32(t.begin), end: uint32(t.end), next: uint32(t.next)}
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v %v", rul3s[t.pegRule], t.begin, t.end, t.next)
}

type tokens32 struct {
	tree    []token32
	ordered [][]token32
}

func (t *tokens32) trim(length int) {
	t.tree = t.tree[0:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) Order() [][]token32 {
	if t.ordered != nil {
		return t.ordered
	}

	depths := make([]int32, 1, math.MaxInt16)
	for i, token := range t.tree {
		if token.pegRule == ruleUnknown {
			t.tree = t.tree[:i]
			break
		}
		depth := int(token.next)
		if length := len(depths); depth >= length {
			depths = depths[:depth+1]
		}
		depths[depth]++
	}
	depths = append(depths, 0)

	ordered, pool := make([][]token32, len(depths)), make([]token32, len(t.tree)+len(depths))
	for i, depth := range depths {
		depth++
		ordered[i], pool, depths[i] = pool[:depth], pool[depth:], 0
	}

	for i, token := range t.tree {
		depth := token.next
		token.next = uint32(i)
		ordered[depth][depths[depth]] = token
		depths[depth]++
	}
	t.ordered = ordered
	return ordered
}

type state32 struct {
	token32
	depths []int32
	leaf   bool
}

func (t *tokens32) AST() *node32 {
	tokens := t.Tokens()
	stack := &element{node: &node32{token32: <-tokens}}
	for token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	return stack.node
}

func (t *tokens32) PreOrder() (<-chan state32, [][]token32) {
	s, ordered := make(chan state32, 6), t.Order()
	go func() {
		var states [8]state32
		for i := range states {
			states[i].depths = make([]int32, len(ordered))
		}
		depths, state, depth := make([]int32, len(ordered)), 0, 1
		write := func(t token32, leaf bool) {
			S := states[state]
			state, S.pegRule, S.begin, S.end, S.next, S.leaf = (state+1)%8, t.pegRule, t.begin, t.end, uint32(depth), leaf
			copy(S.depths, depths)
			s <- S
		}

		states[state].token32 = ordered[0][0]
		depths[0]++
		state++
		a, b := ordered[depth-1][depths[depth-1]-1], ordered[depth][depths[depth]]
	depthFirstSearch:
		for {
			for {
				if i := depths[depth]; i > 0 {
					if c, j := ordered[depth][i-1], depths[depth-1]; a.isParentOf(c) &&
						(j < 2 || !ordered[depth-1][j-2].isParentOf(c)) {
						if c.end != b.begin {
							write(token32{pegRule: ruleIn, begin: c.end, end: b.begin}, true)
						}
						break
					}
				}

				if a.begin < b.begin {
					write(token32{pegRule: rulePre, begin: a.begin, end: b.begin}, true)
				}
				break
			}

			next := depth + 1
			if c := ordered[next][depths[next]]; c.pegRule != ruleUnknown && b.isParentOf(c) {
				write(b, false)
				depths[depth]++
				depth, a, b = next, b, c
				continue
			}

			write(b, true)
			depths[depth]++
			c, parent := ordered[depth][depths[depth]], true
			for {
				if c.pegRule != ruleUnknown && a.isParentOf(c) {
					b = c
					continue depthFirstSearch
				} else if parent && b.end != a.end {
					write(token32{pegRule: ruleSuf, begin: b.end, end: a.end}, true)
				}

				depth--
				if depth > 0 {
					a, b, c = ordered[depth-1][depths[depth-1]-1], a, ordered[depth][depths[depth]]
					parent = a.isParentOf(b)
					continue
				}

				break depthFirstSearch
			}
		}

		close(s)
	}()
	return s, ordered
}

func (t *tokens32) PrintSyntax() {
	tokens, ordered := t.PreOrder()
	max := -1
	for token := range tokens {
		if !token.leaf {
			fmt.Printf("%v", token.begin)
			for i, leaf, depths := 0, int(token.next), token.depths; i < leaf; i++ {
				fmt.Printf(" \x1B[36m%v\x1B[m", rul3s[ordered[i][depths[i]-1].pegRule])
			}
			fmt.Printf(" \x1B[36m%v\x1B[m\n", rul3s[token.pegRule])
		} else if token.begin == token.end {
			fmt.Printf("%v", token.begin)
			for i, leaf, depths := 0, int(token.next), token.depths; i < leaf; i++ {
				fmt.Printf(" \x1B[31m%v\x1B[m", rul3s[ordered[i][depths[i]-1].pegRule])
			}
			fmt.Printf(" \x1B[31m%v\x1B[m\n", rul3s[token.pegRule])
		} else {
			for c, end := token.begin, token.end; c < end; c++ {
				if i := int(c); max+1 < i {
					for j := max; j < i; j++ {
						fmt.Printf("skip %v %v\n", j, token.String())
					}
					max = i
				} else if i := int(c); i <= max {
					for j := i; j <= max; j++ {
						fmt.Printf("dupe %v %v\n", j, token.String())
					}
				} else {
					max = int(c)
				}
				fmt.Printf("%v", c)
				for i, leaf, depths := 0, int(token.next), token.depths; i < leaf; i++ {
					fmt.Printf(" \x1B[34m%v\x1B[m", rul3s[ordered[i][depths[i]-1].pegRule])
				}
				fmt.Printf(" \x1B[34m%v\x1B[m\n", rul3s[token.pegRule])
			}
			fmt.Printf("\n")
		}
	}
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	tokens, _ := t.PreOrder()
	for token := range tokens {
		for c := 0; c < int(token.next); c++ {
			fmt.Printf(" ")
		}
		fmt.Printf("\x1B[34m%v\x1B[m %v\n", rul3s[token.pegRule], strconv.Quote(string(([]rune(buffer)[token.begin:token.end]))))
	}
}

func (t *tokens32) Add(rule pegRule, begin, end, depth uint32, index int) {
	t.tree[index] = token32{pegRule: rule, begin: uint32(begin), end: uint32(end), next: uint32(depth)}
}

func (t *tokens32) Tokens() <-chan token32 {
	s := make(chan token32, 16)
	go func() {
		for _, v := range t.tree {
			s <- v.getToken32()
		}
		close(s)
	}()
	return s
}

func (t *tokens32) Error() []token32 {
	ordered := t.Order()
	length := len(ordered)
	tokens, length := make([]token32, length), length-1
	for i := range tokens {
		o := ordered[length-i]
		if len(o) > 1 {
			tokens[i] = o[len(o)-2].getToken32()
		}
	}
	return tokens
}

func (t *tokens32) Expand(index int) {
	tree := t.tree
	if index >= len(tree) {
		expanded := make([]token32, 2*len(tree))
		copy(expanded, tree)
		t.tree = expanded
	}
}

type ThriftIDL struct {
	Buffer string
	buffer []rune
	rules  [87]func() bool
	Parse  func(rule ...int) error
	Reset  func()
	Pretty bool
	tokens32
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *ThriftIDL
	max token32
}

func (e *parseError) Error() string {
	tokens, error := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		error += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return error
}

func (p *ThriftIDL) PrintSyntaxTree() {
	p.tokens32.PrintSyntaxTree(p.Buffer)
}

func (p *ThriftIDL) Highlighter() {
	p.PrintSyntax()
}

func (p *ThriftIDL) Init() {
	p.buffer = []rune(p.Buffer)
	if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
		p.buffer = append(p.buffer, endSymbol)
	}

	tree := tokens32{tree: make([]token32, math.MaxInt16)}
	var max token32
	position, depth, tokenIndex, buffer, _rules := uint32(0), uint32(0), 0, p.buffer, p.rules

	p.Parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	p.Reset = func() {
		position, tokenIndex, depth = 0, 0, 0
	}

	add := func(rule pegRule, begin uint32) {
		tree.Expand(tokenIndex)
		tree.Add(rule, begin, position, depth, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position, depth}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Document <- <(Skip Header* Definition* !.)> */
		func() bool {
			position0, tokenIndex0, depth0 := position, tokenIndex, depth
			{
				position1 := position
				depth++
				if !_rules[ruleSkip]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3, depth3 := position, tokenIndex, depth
					if !_rules[ruleHeader]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex, depth = position3, tokenIndex3, depth3
				}
			l4:
				{
					position5, tokenIndex5, depth5 := position, tokenIndex, depth
					if !_rules[ruleDefinition]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex, depth = position5, tokenIndex5, depth5
				}
				{
					position6, tokenIndex6, depth6 := position, tokenIndex, depth
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex, depth = position6, tokenIndex6, depth6
				}
				depth--
				add(ruleDocument, position1)
			}
			return true
		l0:
			position, tokenIndex, depth = position0, tokenIndex0, depth0
			return false
		},
		/* 1 Header <- <(Include / CppInclude / Namespace)> */
		func() bool {
			position7, tokenIndex7, depth7 := position, tokenIndex, depth
			{
				position8 := position
				depth++
				{
					position9, tokenIndex9, depth9 := position, tokenIndex, depth
					if !_rules[ruleInclude]() {
						goto l10
					}
					goto l9
				l10:
					position, tokenIndex, depth = position9, tokenIndex9, depth9
					if !_rules[ruleCppInclude]() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex, depth = position9, tokenIndex9, depth9
					if !_rules[ruleNamespace]() {
						goto l7
					}
				}
			l9:
				depth--
				add(ruleHeader, position8)
			}
			return true
		l7:
			position, tokenIndex, depth = position7, tokenIndex7, depth7
			return false
		},
		/* 2 Include <- <(INCLUDE Literal)> */
		func() bool {
			position12, tokenIndex12, depth12 := position, tokenIndex, depth
			{
				position13 := position
				depth++
				if !_rules[ruleINCLUDE]() {
					goto l12
				}
				if !_rules[ruleLiteral]() {
					goto l12
				}
				depth--
				add(ruleInclude, position13)
			}
			return true
		l12:
			position, tokenIndex, depth = position12, tokenIndex12, depth12
			return false
		},
		/* 3 CppInclude <- <(CPPINCLUDE Literal)> */
		func() bool {
			position14, tokenIndex14, depth14 := position, tokenIndex, depth
			{
				position15 := position
				depth++
				if !_rules[ruleCPPINCLUDE]() {
					goto l14
				}
				if !_rules[ruleLiteral]() {
					goto l14
				}
				depth--
				add(ruleCppInclude, position15)
			}
			return true
		l14:
			position, tokenIndex, depth = position14, tokenIndex14, depth14
			return false
		},
		/* 4 Namespace <- <(NAMESPACE NamespaceScope Identifier Annotations?)> */
		func() bool {
			position16, tokenIndex16, depth16 := position, tokenIndex, depth
			{
				position17 := position
				depth++
				if !_rules[ruleNAMESPACE]() {
					goto l16
				}
				if !_rules[ruleNamespaceScope]() {
					goto l16
				}
				if !_rules[ruleIdentifier]() {
					goto l16
				}
				{
					position18, tokenIndex18, depth18 := position, tokenIndex, depth
					if !_rules[ruleAnnotations]() {
						goto l18
					}
					goto l19
				l18:
					position, tokenIndex, depth = position18, tokenIndex18, depth18
				}
			l19:
				depth--
				add(ruleNamespace, position17)
			}
			return true
		l16:
			position, tokenIndex, depth = position16, tokenIndex16, depth16
			return false
		},
		/* 5 NamespaceScope <- <((<'*'> Skip) / Identifier)> */
		func() bool {
			position20, tokenIndex20, depth20 := position, tokenIndex, depth
			{
				position21 := position
				depth++
				{
					position22, tokenIndex22, depth22 := position, tokenIndex, depth
					{
						position24 := position
						depth++
						if buffer[position] != rune('*') {
							goto l23
						}
						position++
						depth--
						add(rulePegText, position24)
					}
					if !_rules[ruleSkip]() {
						goto l23
					}
					goto l22
				l23:
					position, tokenIndex, depth = position22, tokenIndex22, depth22
					if !_rules[ruleIdentifier]() {
						goto l20
					}
				}
			l22:
				depth--
				add(ruleNamespaceScope, position21)
			}
			return true
		l20:
			position, tokenIndex, depth = position20, tokenIndex20, depth20
			return false
		},
		/* 6 Definition <- <((Const / Typedef / Enum / Struct / Union / Service / Exception) Annotations?)> */
		func() bool {
			position25, tokenIndex25, depth25 := position, tokenIndex, depth
			{
				position26 := position
				depth++
				{
					position27, tokenIndex27, depth27 := position, tokenIndex, depth
					if !_rules[ruleConst]() {
						goto l28
					}
					goto l27
				l28:
					position, tokenIndex, depth = position27, tokenIndex27, depth27
					if !_rules[ruleTypedef]() {
						goto l29
					}
					goto l27
				l29:
					position, tokenIndex, depth = position27, tokenIndex27, depth27
					if !_rules[ruleEnum]() {
						goto l30
					}
					goto l27
				l30:
					position, tokenIndex, depth = position27, tokenIndex27, depth27
					if !_rules[ruleStruct]() {
						goto l31
					}
					goto l27
				l31:
					position, tokenIndex, depth = position27, tokenIndex27, depth27
					if !_rules[ruleUnion]() {
						goto l32
					}
					goto l27
				l32:
					position, tokenIndex, depth = position27, tokenIndex27, depth27
					if !_rules[ruleService]() {
						goto l33
					}
					goto l27
				l33:
					position, tokenIndex, depth = position27, tokenIndex27, depth27
					if !_rules[ruleException]() {
						goto l25
					}
				}
			l27:
				{
					position34, tokenIndex34, depth34 := position, tokenIndex, depth
					if !_rules[ruleAnnotations]() {
						goto l34
					}
					goto l35
				l34:
					position, tokenIndex, depth = position34, tokenIndex34, depth34
				}
			l35:
				depth--
				add(ruleDefinition, position26)
			}
			return true
		l25:
			position, tokenIndex, depth = position25, tokenIndex25, depth25
			return false
		},
		/* 7 Const <- <(CONST FieldType Identifier EQUAL ConstValue ListSeparator?)> */
		func() bool {
			position36, tokenIndex36, depth36 := position, tokenIndex, depth
			{
				position37 := position
				depth++
				if !_rules[ruleCONST]() {
					goto l36
				}
				if !_rules[ruleFieldType]() {
					goto l36
				}
				if !_rules[ruleIdentifier]() {
					goto l36
				}
				if !_rules[ruleEQUAL]() {
					goto l36
				}
				if !_rules[ruleConstValue]() {
					goto l36
				}
				{
					position38, tokenIndex38, depth38 := position, tokenIndex, depth
					if !_rules[ruleListSeparator]() {
						goto l38
					}
					goto l39
				l38:
					position, tokenIndex, depth = position38, tokenIndex38, depth38
				}
			l39:
				depth--
				add(ruleConst, position37)
			}
			return true
		l36:
			position, tokenIndex, depth = position36, tokenIndex36, depth36
			return false
		},
		/* 8 Typedef <- <(TYPEDEF FieldType Identifier)> */
		func() bool {
			position40, tokenIndex40, depth40 := position, tokenIndex, depth
			{
				position41 := position
				depth++
				if !_rules[ruleTYPEDEF]() {
					goto l40
				}
				if !_rules[ruleFieldType]() {
					goto l40
				}
				if !_rules[ruleIdentifier]() {
					goto l40
				}
				depth--
				add(ruleTypedef, position41)
			}
			return true
		l40:
			position, tokenIndex, depth = position40, tokenIndex40, depth40
			return false
		},
		/* 9 Enum <- <(ENUM Identifier LWING (Identifier (EQUAL IntConstant)? Annotations? ListSeparator?)* RWING)> */
		func() bool {
			position42, tokenIndex42, depth42 := position, tokenIndex, depth
			{
				position43 := position
				depth++
				if !_rules[ruleENUM]() {
					goto l42
				}
				if !_rules[ruleIdentifier]() {
					goto l42
				}
				if !_rules[ruleLWING]() {
					goto l42
				}
			l44:
				{
					position45, tokenIndex45, depth45 := position, tokenIndex, depth
					if !_rules[ruleIdentifier]() {
						goto l45
					}
					{
						position46, tokenIndex46, depth46 := position, tokenIndex, depth
						if !_rules[ruleEQUAL]() {
							goto l46
						}
						if !_rules[ruleIntConstant]() {
							goto l46
						}
						goto l47
					l46:
						position, tokenIndex, depth = position46, tokenIndex46, depth46
					}
				l47:
					{
						position48, tokenIndex48, depth48 := position, tokenIndex, depth
						if !_rules[ruleAnnotations]() {
							goto l48
						}
						goto l49
					l48:
						position, tokenIndex, depth = position48, tokenIndex48, depth48
					}
				l49:
					{
						position50, tokenIndex50, depth50 := position, tokenIndex, depth
						if !_rules[ruleListSeparator]() {
							goto l50
						}
						goto l51
					l50:
						position, tokenIndex, depth = position50, tokenIndex50, depth50
					}
				l51:
					goto l44
				l45:
					position, tokenIndex, depth = position45, tokenIndex45, depth45
				}
				if !_rules[ruleRWING]() {
					goto l42
				}
				depth--
				add(ruleEnum, position43)
			}
			return true
		l42:
			position, tokenIndex, depth = position42, tokenIndex42, depth42
			return false
		},
		/* 10 Struct <- <(STRUCT Identifier LWING Field* RWING)> */
		func() bool {
			position52, tokenIndex52, depth52 := position, tokenIndex, depth
			{
				position53 := position
				depth++
				if !_rules[ruleSTRUCT]() {
					goto l52
				}
				if !_rules[ruleIdentifier]() {
					goto l52
				}
				if !_rules[ruleLWING]() {
					goto l52
				}
			l54:
				{
					position55, tokenIndex55, depth55 := position, tokenIndex, depth
					if !_rules[ruleField]() {
						goto l55
					}
					goto l54
				l55:
					position, tokenIndex, depth = position55, tokenIndex55, depth55
				}
				if !_rules[ruleRWING]() {
					goto l52
				}
				depth--
				add(ruleStruct, position53)
			}
			return true
		l52:
			position, tokenIndex, depth = position52, tokenIndex52, depth52
			return false
		},
		/* 11 Union <- <(UNION Identifier LWING Field* RWING)> */
		func() bool {
			position56, tokenIndex56, depth56 := position, tokenIndex, depth
			{
				position57 := position
				depth++
				if !_rules[ruleUNION]() {
					goto l56
				}
				if !_rules[ruleIdentifier]() {
					goto l56
				}
				if !_rules[ruleLWING]() {
					goto l56
				}
			l58:
				{
					position59, tokenIndex59, depth59 := position, tokenIndex, depth
					if !_rules[ruleField]() {
						goto l59
					}
					goto l58
				l59:
					position, tokenIndex, depth = position59, tokenIndex59, depth59
				}
				if !_rules[ruleRWING]() {
					goto l56
				}
				depth--
				add(ruleUnion, position57)
			}
			return true
		l56:
			position, tokenIndex, depth = position56, tokenIndex56, depth56
			return false
		},
		/* 12 Service <- <(SERVICE Identifier (EXTENDS Identifier)? LWING Function* RWING)> */
		func() bool {
			position60, tokenIndex60, depth60 := position, tokenIndex, depth
			{
				position61 := position
				depth++
				if !_rules[ruleSERVICE]() {
					goto l60
				}
				if !_rules[ruleIdentifier]() {
					goto l60
				}
				{
					position62, tokenIndex62, depth62 := position, tokenIndex, depth
					if !_rules[ruleEXTENDS]() {
						goto l62
					}
					if !_rules[ruleIdentifier]() {
						goto l62
					}
					goto l63
				l62:
					position, tokenIndex, depth = position62, tokenIndex62, depth62
				}
			l63:
				if !_rules[ruleLWING]() {
					goto l60
				}
			l64:
				{
					position65, tokenIndex65, depth65 := position, tokenIndex, depth
					if !_rules[ruleFunction]() {
						goto l65
					}
					goto l64
				l65:
					position, tokenIndex, depth = position65, tokenIndex65, depth65
				}
				if !_rules[ruleRWING]() {
					goto l60
				}
				depth--
				add(ruleService, position61)
			}
			return true
		l60:
			position, tokenIndex, depth = position60, tokenIndex60, depth60
			return false
		},
		/* 13 Exception <- <(EXCEPTION Identifier LWING Field* RWING)> */
		func() bool {
			position66, tokenIndex66, depth66 := position, tokenIndex, depth
			{
				position67 := position
				depth++
				if !_rules[ruleEXCEPTION]() {
					goto l66
				}
				if !_rules[ruleIdentifier]() {
					goto l66
				}
				if !_rules[ruleLWING]() {
					goto l66
				}
			l68:
				{
					position69, tokenIndex69, depth69 := position, tokenIndex, depth
					if !_rules[ruleField]() {
						goto l69
					}
					goto l68
				l69:
					position, tokenIndex, depth = position69, tokenIndex69, depth69
				}
				if !_rules[ruleRWING]() {
					goto l66
				}
				depth--
				add(ruleException, position67)
			}
			return true
		l66:
			position, tokenIndex, depth = position66, tokenIndex66, depth66
			return false
		},
		/* 14 Field <- <(FieldId? FieldReq? FieldType Identifier (EQUAL ConstValue)? Annotations? ListSeparator?)> */
		func() bool {
			position70, tokenIndex70, depth70 := position, tokenIndex, depth
			{
				position71 := position
				depth++
				{
					position72, tokenIndex72, depth72 := position, tokenIndex, depth
					if !_rules[ruleFieldId]() {
						goto l72
					}
					goto l73
				l72:
					position, tokenIndex, depth = position72, tokenIndex72, depth72
				}
			l73:
				{
					position74, tokenIndex74, depth74 := position, tokenIndex, depth
					if !_rules[ruleFieldReq]() {
						goto l74
					}
					goto l75
				l74:
					position, tokenIndex, depth = position74, tokenIndex74, depth74
				}
			l75:
				if !_rules[ruleFieldType]() {
					goto l70
				}
				if !_rules[ruleIdentifier]() {
					goto l70
				}
				{
					position76, tokenIndex76, depth76 := position, tokenIndex, depth
					if !_rules[ruleEQUAL]() {
						goto l76
					}
					if !_rules[ruleConstValue]() {
						goto l76
					}
					goto l77
				l76:
					position, tokenIndex, depth = position76, tokenIndex76, depth76
				}
			l77:
				{
					position78, tokenIndex78, depth78 := position, tokenIndex, depth
					if !_rules[ruleAnnotations]() {
						goto l78
					}
					goto l79
				l78:
					position, tokenIndex, depth = position78, tokenIndex78, depth78
				}
			l79:
				{
					position80, tokenIndex80, depth80 := position, tokenIndex, depth
					if !_rules[ruleListSeparator]() {
						goto l80
					}
					goto l81
				l80:
					position, tokenIndex, depth = position80, tokenIndex80, depth80
				}
			l81:
				depth--
				add(ruleField, position71)
			}
			return true
		l70:
			position, tokenIndex, depth = position70, tokenIndex70, depth70
			return false
		},
		/* 15 FieldId <- <(IntConstant ':' Skip)> */
		func() bool {
			position82, tokenIndex82, depth82 := position, tokenIndex, depth
			{
				position83 := position
				depth++
				if !_rules[ruleIntConstant]() {
					goto l82
				}
				if buffer[position] != rune(':') {
					goto l82
				}
				position++
				if !_rules[ruleSkip]() {
					goto l82
				}
				depth--
				add(ruleFieldId, position83)
			}
			return true
		l82:
			position, tokenIndex, depth = position82, tokenIndex82, depth82
			return false
		},
		/* 16 FieldReq <- <(<(('r' 'e' 'q' 'u' 'i' 'r' 'e' 'd') / ('o' 'p' 't' 'i' 'o' 'n' 'a' 'l'))> Skip)> */
		func() bool {
			position84, tokenIndex84, depth84 := position, tokenIndex, depth
			{
				position85 := position
				depth++
				{
					position86 := position
					depth++
					{
						position87, tokenIndex87, depth87 := position, tokenIndex, depth
						if buffer[position] != rune('r') {
							goto l88
						}
						position++
						if buffer[position] != rune('e') {
							goto l88
						}
						position++
						if buffer[position] != rune('q') {
							goto l88
						}
						position++
						if buffer[position] != rune('u') {
							goto l88
						}
						position++
						if buffer[position] != rune('i') {
							goto l88
						}
						position++
						if buffer[position] != rune('r') {
							goto l88
						}
						position++
						if buffer[position] != rune('e') {
							goto l88
						}
						position++
						if buffer[position] != rune('d') {
							goto l88
						}
						position++
						goto l87
					l88:
						position, tokenIndex, depth = position87, tokenIndex87, depth87
						if buffer[position] != rune('o') {
							goto l84
						}
						position++
						if buffer[position] != rune('p') {
							goto l84
						}
						position++
						if buffer[position] != rune('t') {
							goto l84
						}
						position++
						if buffer[position] != rune('i') {
							goto l84
						}
						position++
						if buffer[position] != rune('o') {
							goto l84
						}
						position++
						if buffer[position] != rune('n') {
							goto l84
						}
						position++
						if buffer[position] != rune('a') {
							goto l84
						}
						position++
						if buffer[position] != rune('l') {
							goto l84
						}
						position++
					}
				l87:
					depth--
					add(rulePegText, position86)
				}
				if !_rules[ruleSkip]() {
					goto l84
				}
				depth--
				add(ruleFieldReq, position85)
			}
			return true
		l84:
			position, tokenIndex, depth = position84, tokenIndex84, depth84
			return false
		},
		/* 17 Function <- <(ONEWAY? FunctionType Identifier LPAR Field* RPAR Throws? Annotations? ListSeparator?)> */
		func() bool {
			position89, tokenIndex89, depth89 := position, tokenIndex, depth
			{
				position90 := position
				depth++
				{
					position91, tokenIndex91, depth91 := position, tokenIndex, depth
					if !_rules[ruleONEWAY]() {
						goto l91
					}
					goto l92
				l91:
					position, tokenIndex, depth = position91, tokenIndex91, depth91
				}
			l92:
				if !_rules[ruleFunctionType]() {
					goto l89
				}
				if !_rules[ruleIdentifier]() {
					goto l89
				}
				if !_rules[ruleLPAR]() {
					goto l89
				}
			l93:
				{
					position94, tokenIndex94, depth94 := position, tokenIndex, depth
					if !_rules[ruleField]() {
						goto l94
					}
					goto l93
				l94:
					position, tokenIndex, depth = position94, tokenIndex94, depth94
				}
				if !_rules[ruleRPAR]() {
					goto l89
				}
				{
					position95, tokenIndex95, depth95 := position, tokenIndex, depth
					if !_rules[ruleThrows]() {
						goto l95
					}
					goto l96
				l95:
					position, tokenIndex, depth = position95, tokenIndex95, depth95
				}
			l96:
				{
					position97, tokenIndex97, depth97 := position, tokenIndex, depth
					if !_rules[ruleAnnotations]() {
						goto l97
					}
					goto l98
				l97:
					position, tokenIndex, depth = position97, tokenIndex97, depth97
				}
			l98:
				{
					position99, tokenIndex99, depth99 := position, tokenIndex, depth
					if !_rules[ruleListSeparator]() {
						goto l99
					}
					goto l100
				l99:
					position, tokenIndex, depth = position99, tokenIndex99, depth99
				}
			l100:
				depth--
				add(ruleFunction, position90)
			}
			return true
		l89:
			position, tokenIndex, depth = position89, tokenIndex89, depth89
			return false
		},
		/* 18 FunctionType <- <(VOID / FieldType)> */
		func() bool {
			position101, tokenIndex101, depth101 := position, tokenIndex, depth
			{
				position102 := position
				depth++
				{
					position103, tokenIndex103, depth103 := position, tokenIndex, depth
					if !_rules[ruleVOID]() {
						goto l104
					}
					goto l103
				l104:
					position, tokenIndex, depth = position103, tokenIndex103, depth103
					if !_rules[ruleFieldType]() {
						goto l101
					}
				}
			l103:
				depth--
				add(ruleFunctionType, position102)
			}
			return true
		l101:
			position, tokenIndex, depth = position101, tokenIndex101, depth101
			return false
		},
		/* 19 Throws <- <(THROWS LPAR Field* RPAR)> */
		func() bool {
			position105, tokenIndex105, depth105 := position, tokenIndex, depth
			{
				position106 := position
				depth++
				if !_rules[ruleTHROWS]() {
					goto l105
				}
				if !_rules[ruleLPAR]() {
					goto l105
				}
			l107:
				{
					position108, tokenIndex108, depth108 := position, tokenIndex, depth
					if !_rules[ruleField]() {
						goto l108
					}
					goto l107
				l108:
					position, tokenIndex, depth = position108, tokenIndex108, depth108
				}
				if !_rules[ruleRPAR]() {
					goto l105
				}
				depth--
				add(ruleThrows, position106)
			}
			return true
		l105:
			position, tokenIndex, depth = position105, tokenIndex105, depth105
			return false
		},
		/* 20 FieldType <- <((ContainerType / BaseType / Identifier) Annotations?)> */
		func() bool {
			position109, tokenIndex109, depth109 := position, tokenIndex, depth
			{
				position110 := position
				depth++
				{
					position111, tokenIndex111, depth111 := position, tokenIndex, depth
					if !_rules[ruleContainerType]() {
						goto l112
					}
					goto l111
				l112:
					position, tokenIndex, depth = position111, tokenIndex111, depth111
					if !_rules[ruleBaseType]() {
						goto l113
					}
					goto l111
				l113:
					position, tokenIndex, depth = position111, tokenIndex111, depth111
					if !_rules[ruleIdentifier]() {
						goto l109
					}
				}
			l111:
				{
					position114, tokenIndex114, depth114 := position, tokenIndex, depth
					if !_rules[ruleAnnotations]() {
						goto l114
					}
					goto l115
				l114:
					position, tokenIndex, depth = position114, tokenIndex114, depth114
				}
			l115:
				depth--
				add(ruleFieldType, position110)
			}
			return true
		l109:
			position, tokenIndex, depth = position109, tokenIndex109, depth109
			return false
		},
		/* 21 BaseType <- <(BOOL / BYTE / I8 / I16 / I32 / I64 / DOUBLE / STRING / (BINARY Skip))> */
		func() bool {
			position116, tokenIndex116, depth116 := position, tokenIndex, depth
			{
				position117 := position
				depth++
				{
					position118, tokenIndex118, depth118 := position, tokenIndex, depth
					if !_rules[ruleBOOL]() {
						goto l119
					}
					goto l118
				l119:
					position, tokenIndex, depth = position118, tokenIndex118, depth118
					if !_rules[ruleBYTE]() {
						goto l120
					}
					goto l118
				l120:
					position, tokenIndex, depth = position118, tokenIndex118, depth118
					if !_rules[ruleI8]() {
						goto l121
					}
					goto l118
				l121:
					position, tokenIndex, depth = position118, tokenIndex118, depth118
					if !_rules[ruleI16]() {
						goto l122
					}
					goto l118
				l122:
					position, tokenIndex, depth = position118, tokenIndex118, depth118
					if !_rules[ruleI32]() {
						goto l123
					}
					goto l118
				l123:
					position, tokenIndex, depth = position118, tokenIndex118, depth118
					if !_rules[ruleI64]() {
						goto l124
					}
					goto l118
				l124:
					position, tokenIndex, depth = position118, tokenIndex118, depth118
					if !_rules[ruleDOUBLE]() {
						goto l125
					}
					goto l118
				l125:
					position, tokenIndex, depth = position118, tokenIndex118, depth118
					if !_rules[ruleSTRING]() {
						goto l126
					}
					goto l118
				l126:
					position, tokenIndex, depth = position118, tokenIndex118, depth118
					if !_rules[ruleBINARY]() {
						goto l116
					}
					if !_rules[ruleSkip]() {
						goto l116
					}
				}
			l118:
				depth--
				add(ruleBaseType, position117)
			}
			return true
		l116:
			position, tokenIndex, depth = position116, tokenIndex116, depth116
			return false
		},
		/* 22 ContainerType <- <(MapType / SetType / ListType)> */
		func() bool {
			position127, tokenIndex127, depth127 := position, tokenIndex, depth
			{
				position128 := position
				depth++
				{
					position129, tokenIndex129, depth129 := position, tokenIndex, depth
					if !_rules[ruleMapType]() {
						goto l130
					}
					goto l129
				l130:
					position, tokenIndex, depth = position129, tokenIndex129, depth129
					if !_rules[ruleSetType]() {
						goto l131
					}
					goto l129
				l131:
					position, tokenIndex, depth = position129, tokenIndex129, depth129
					if !_rules[ruleListType]() {
						goto l127
					}
				}
			l129:
				depth--
				add(ruleContainerType, position128)
			}
			return true
		l127:
			position, tokenIndex, depth = position127, tokenIndex127, depth127
			return false
		},
		/* 23 MapType <- <(MAP CppType? LPOINT FieldType COMMA FieldType RPOINT)> */
		func() bool {
			position132, tokenIndex132, depth132 := position, tokenIndex, depth
			{
				position133 := position
				depth++
				if !_rules[ruleMAP]() {
					goto l132
				}
				{
					position134, tokenIndex134, depth134 := position, tokenIndex, depth
					if !_rules[ruleCppType]() {
						goto l134
					}
					goto l135
				l134:
					position, tokenIndex, depth = position134, tokenIndex134, depth134
				}
			l135:
				if !_rules[ruleLPOINT]() {
					goto l132
				}
				if !_rules[ruleFieldType]() {
					goto l132
				}
				if !_rules[ruleCOMMA]() {
					goto l132
				}
				if !_rules[ruleFieldType]() {
					goto l132
				}
				if !_rules[ruleRPOINT]() {
					goto l132
				}
				depth--
				add(ruleMapType, position133)
			}
			return true
		l132:
			position, tokenIndex, depth = position132, tokenIndex132, depth132
			return false
		},
		/* 24 SetType <- <(SET CppType? LPOINT FieldType RPOINT)> */
		func() bool {
			position136, tokenIndex136, depth136 := position, tokenIndex, depth
			{
				position137 := position
				depth++
				if !_rules[ruleSET]() {
					goto l136
				}
				{
					position138, tokenIndex138, depth138 := position, tokenIndex, depth
					if !_rules[ruleCppType]() {
						goto l138
					}
					goto l139
				l138:
					position, tokenIndex, depth = position138, tokenIndex138, depth138
				}
			l139:
				if !_rules[ruleLPOINT]() {
					goto l136
				}
				if !_rules[ruleFieldType]() {
					goto l136
				}
				if !_rules[ruleRPOINT]() {
					goto l136
				}
				depth--
				add(ruleSetType, position137)
			}
			return true
		l136:
			position, tokenIndex, depth = position136, tokenIndex136, depth136
			return false
		},
		/* 25 ListType <- <(LIST LPOINT FieldType RPOINT CppType?)> */
		func() bool {
			position140, tokenIndex140, depth140 := position, tokenIndex, depth
			{
				position141 := position
				depth++
				if !_rules[ruleLIST]() {
					goto l140
				}
				if !_rules[ruleLPOINT]() {
					goto l140
				}
				if !_rules[ruleFieldType]() {
					goto l140
				}
				if !_rules[ruleRPOINT]() {
					goto l140
				}
				{
					position142, tokenIndex142, depth142 := position, tokenIndex, depth
					if !_rules[ruleCppType]() {
						goto l142
					}
					goto l143
				l142:
					position, tokenIndex, depth = position142, tokenIndex142, depth142
				}
			l143:
				depth--
				add(ruleListType, position141)
			}
			return true
		l140:
			position, tokenIndex, depth = position140, tokenIndex140, depth140
			return false
		},
		/* 26 CppType <- <(CPPTYPE Literal Skip)> */
		func() bool {
			position144, tokenIndex144, depth144 := position, tokenIndex, depth
			{
				position145 := position
				depth++
				if !_rules[ruleCPPTYPE]() {
					goto l144
				}
				if !_rules[ruleLiteral]() {
					goto l144
				}
				if !_rules[ruleSkip]() {
					goto l144
				}
				depth--
				add(ruleCppType, position145)
			}
			return true
		l144:
			position, tokenIndex, depth = position144, tokenIndex144, depth144
			return false
		},
		/* 27 ConstValue <- <(DoubleConstant / IntConstant / Literal / Identifier / ConstList / ConstMap)> */
		func() bool {
			position146, tokenIndex146, depth146 := position, tokenIndex, depth
			{
				position147 := position
				depth++
				{
					position148, tokenIndex148, depth148 := position, tokenIndex, depth
					if !_rules[ruleDoubleConstant]() {
						goto l149
					}
					goto l148
				l149:
					position, tokenIndex, depth = position148, tokenIndex148, depth148
					if !_rules[ruleIntConstant]() {
						goto l150
					}
					goto l148
				l150:
					position, tokenIndex, depth = position148, tokenIndex148, depth148
					if !_rules[ruleLiteral]() {
						goto l151
					}
					goto l148
				l151:
					position, tokenIndex, depth = position148, tokenIndex148, depth148
					if !_rules[ruleIdentifier]() {
						goto l152
					}
					goto l148
				l152:
					position, tokenIndex, depth = position148, tokenIndex148, depth148
					if !_rules[ruleConstList]() {
						goto l153
					}
					goto l148
				l153:
					position, tokenIndex, depth = position148, tokenIndex148, depth148
					if !_rules[ruleConstMap]() {
						goto l146
					}
				}
			l148:
				depth--
				add(ruleConstValue, position147)
			}
			return true
		l146:
			position, tokenIndex, depth = position146, tokenIndex146, depth146
			return false
		},
		/* 28 IntConstant <- <(<(('0' 'x' ([0-9] / [A-Z] / [a-z])+) / ('0' 'o' Digit+) / (('+' / '-')? Digit+))> Skip)> */
		func() bool {
			position154, tokenIndex154, depth154 := position, tokenIndex, depth
			{
				position155 := position
				depth++
				{
					position156 := position
					depth++
					{
						position157, tokenIndex157, depth157 := position, tokenIndex, depth
						if buffer[position] != rune('0') {
							goto l158
						}
						position++
						if buffer[position] != rune('x') {
							goto l158
						}
						position++
						{
							position161, tokenIndex161, depth161 := position, tokenIndex, depth
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l162
							}
							position++
							goto l161
						l162:
							position, tokenIndex, depth = position161, tokenIndex161, depth161
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l163
							}
							position++
							goto l161
						l163:
							position, tokenIndex, depth = position161, tokenIndex161, depth161
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l158
							}
							position++
						}
					l161:
					l159:
						{
							position160, tokenIndex160, depth160 := position, tokenIndex, depth
							{
								position164, tokenIndex164, depth164 := position, tokenIndex, depth
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l165
								}
								position++
								goto l164
							l165:
								position, tokenIndex, depth = position164, tokenIndex164, depth164
								if c := buffer[position]; c < rune('A') || c > rune('Z') {
									goto l166
								}
								position++
								goto l164
							l166:
								position, tokenIndex, depth = position164, tokenIndex164, depth164
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l160
								}
								position++
							}
						l164:
							goto l159
						l160:
							position, tokenIndex, depth = position160, tokenIndex160, depth160
						}
						goto l157
					l158:
						position, tokenIndex, depth = position157, tokenIndex157, depth157
						if buffer[position] != rune('0') {
							goto l167
						}
						position++
						if buffer[position] != rune('o') {
							goto l167
						}
						position++
						if !_rules[ruleDigit]() {
							goto l167
						}
					l168:
						{
							position169, tokenIndex169, depth169 := position, tokenIndex, depth
							if !_rules[ruleDigit]() {
								goto l169
							}
							goto l168
						l169:
							position, tokenIndex, depth = position169, tokenIndex169, depth169
						}
						goto l157
					l167:
						position, tokenIndex, depth = position157, tokenIndex157, depth157
						{
							position170, tokenIndex170, depth170 := position, tokenIndex, depth
							{
								position172, tokenIndex172, depth172 := position, tokenIndex, depth
								if buffer[position] != rune('+') {
									goto l173
								}
								position++
								goto l172
							l173:
								position, tokenIndex, depth = position172, tokenIndex172, depth172
								if buffer[position] != rune('-') {
									goto l170
								}
								position++
							}
						l172:
							goto l171
						l170:
							position, tokenIndex, depth = position170, tokenIndex170, depth170
						}
					l171:
						if !_rules[ruleDigit]() {
							goto l154
						}
					l174:
						{
							position175, tokenIndex175, depth175 := position, tokenIndex, depth
							if !_rules[ruleDigit]() {
								goto l175
							}
							goto l174
						l175:
							position, tokenIndex, depth = position175, tokenIndex175, depth175
						}
					}
				l157:
					depth--
					add(rulePegText, position156)
				}
				if !_rules[ruleSkip]() {
					goto l154
				}
				depth--
				add(ruleIntConstant, position155)
			}
			return true
		l154:
			position, tokenIndex, depth = position154, tokenIndex154, depth154
			return false
		},
		/* 29 DoubleConstant <- <(<(('+' / '-')? ((Digit* '.' Digit+ Exponent?) / (Digit+ Exponent)))> Skip)> */
		func() bool {
			position176, tokenIndex176, depth176 := position, tokenIndex, depth
			{
				position177 := position
				depth++
				{
					position178 := position
					depth++
					{
						position179, tokenIndex179, depth179 := position, tokenIndex, depth
						{
							position181, tokenIndex181, depth181 := position, tokenIndex, depth
							if buffer[position] != rune('+') {
								goto l182
							}
							position++
							goto l181
						l182:
							position, tokenIndex, depth = position181, tokenIndex181, depth181
							if buffer[position] != rune('-') {
								goto l179
							}
							position++
						}
					l181:
						goto l180
					l179:
						position, tokenIndex, depth = position179, tokenIndex179, depth179
					}
				l180:
					{
						position183, tokenIndex183, depth183 := position, tokenIndex, depth
					l185:
						{
							position186, tokenIndex186, depth186 := position, tokenIndex, depth
							if !_rules[ruleDigit]() {
								goto l186
							}
							goto l185
						l186:
							position, tokenIndex, depth = position186, tokenIndex186, depth186
						}
						if buffer[position] != rune('.') {
							goto l184
						}
						position++
						if !_rules[ruleDigit]() {
							goto l184
						}
					l187:
						{
							position188, tokenIndex188, depth188 := position, tokenIndex, depth
							if !_rules[ruleDigit]() {
								goto l188
							}
							goto l187
						l188:
							position, tokenIndex, depth = position188, tokenIndex188, depth188
						}
						{
							position189, tokenIndex189, depth189 := position, tokenIndex, depth
							if !_rules[ruleExponent]() {
								goto l189
							}
							goto l190
						l189:
							position, tokenIndex, depth = position189, tokenIndex189, depth189
						}
					l190:
						goto l183
					l184:
						position, tokenIndex, depth = position183, tokenIndex183, depth183
						if !_rules[ruleDigit]() {
							goto l176
						}
					l191:
						{
							position192, tokenIndex192, depth192 := position, tokenIndex, depth
							if !_rules[ruleDigit]() {
								goto l192
							}
							goto l191
						l192:
							position, tokenIndex, depth = position192, tokenIndex192, depth192
						}
						if !_rules[ruleExponent]() {
							goto l176
						}
					}
				l183:
					depth--
					add(rulePegText, position178)
				}
				if !_rules[ruleSkip]() {
					goto l176
				}
				depth--
				add(ruleDoubleConstant, position177)
			}
			return true
		l176:
			position, tokenIndex, depth = position176, tokenIndex176, depth176
			return false
		},
		/* 30 Exponent <- <(('e' / 'E') IntConstant)> */
		func() bool {
			position193, tokenIndex193, depth193 := position, tokenIndex, depth
			{
				position194 := position
				depth++
				{
					position195, tokenIndex195, depth195 := position, tokenIndex, depth
					if buffer[position] != rune('e') {
						goto l196
					}
					position++
					goto l195
				l196:
					position, tokenIndex, depth = position195, tokenIndex195, depth195
					if buffer[position] != rune('E') {
						goto l193
					}
					position++
				}
			l195:
				if !_rules[ruleIntConstant]() {
					goto l193
				}
				depth--
				add(ruleExponent, position194)
			}
			return true
		l193:
			position, tokenIndex, depth = position193, tokenIndex193, depth193
			return false
		},
		/* 31 Annotations <- <(LPAR Annotation+ RPAR)> */
		func() bool {
			position197, tokenIndex197, depth197 := position, tokenIndex, depth
			{
				position198 := position
				depth++
				if !_rules[ruleLPAR]() {
					goto l197
				}
				if !_rules[ruleAnnotation]() {
					goto l197
				}
			l199:
				{
					position200, tokenIndex200, depth200 := position, tokenIndex, depth
					if !_rules[ruleAnnotation]() {
						goto l200
					}
					goto l199
				l200:
					position, tokenIndex, depth = position200, tokenIndex200, depth200
				}
				if !_rules[ruleRPAR]() {
					goto l197
				}
				depth--
				add(ruleAnnotations, position198)
			}
			return true
		l197:
			position, tokenIndex, depth = position197, tokenIndex197, depth197
			return false
		},
		/* 32 Annotation <- <(Identifier EQUAL Literal ListSeparator?)> */
		func() bool {
			position201, tokenIndex201, depth201 := position, tokenIndex, depth
			{
				position202 := position
				depth++
				if !_rules[ruleIdentifier]() {
					goto l201
				}
				if !_rules[ruleEQUAL]() {
					goto l201
				}
				if !_rules[ruleLiteral]() {
					goto l201
				}
				{
					position203, tokenIndex203, depth203 := position, tokenIndex, depth
					if !_rules[ruleListSeparator]() {
						goto l203
					}
					goto l204
				l203:
					position, tokenIndex, depth = position203, tokenIndex203, depth203
				}
			l204:
				depth--
				add(ruleAnnotation, position202)
			}
			return true
		l201:
			position, tokenIndex, depth = position201, tokenIndex201, depth201
			return false
		},
		/* 33 ConstList <- <(LBRK (ConstValue ListSeparator?)* RBRK)> */
		func() bool {
			position205, tokenIndex205, depth205 := position, tokenIndex, depth
			{
				position206 := position
				depth++
				if !_rules[ruleLBRK]() {
					goto l205
				}
			l207:
				{
					position208, tokenIndex208, depth208 := position, tokenIndex, depth
					if !_rules[ruleConstValue]() {
						goto l208
					}
					{
						position209, tokenIndex209, depth209 := position, tokenIndex, depth
						if !_rules[ruleListSeparator]() {
							goto l209
						}
						goto l210
					l209:
						position, tokenIndex, depth = position209, tokenIndex209, depth209
					}
				l210:
					goto l207
				l208:
					position, tokenIndex, depth = position208, tokenIndex208, depth208
				}
				if !_rules[ruleRBRK]() {
					goto l205
				}
				depth--
				add(ruleConstList, position206)
			}
			return true
		l205:
			position, tokenIndex, depth = position205, tokenIndex205, depth205
			return false
		},
		/* 34 ConstMap <- <(LWING (ConstValue COLON ConstValue ListSeparator?)* RWING)> */
		func() bool {
			position211, tokenIndex211, depth211 := position, tokenIndex, depth
			{
				position212 := position
				depth++
				if !_rules[ruleLWING]() {
					goto l211
				}
			l213:
				{
					position214, tokenIndex214, depth214 := position, tokenIndex, depth
					if !_rules[ruleConstValue]() {
						goto l214
					}
					if !_rules[ruleCOLON]() {
						goto l214
					}
					if !_rules[ruleConstValue]() {
						goto l214
					}
					{
						position215, tokenIndex215, depth215 := position, tokenIndex, depth
						if !_rules[ruleListSeparator]() {
							goto l215
						}
						goto l216
					l215:
						position, tokenIndex, depth = position215, tokenIndex215, depth215
					}
				l216:
					goto l213
				l214:
					position, tokenIndex, depth = position214, tokenIndex214, depth214
				}
				if !_rules[ruleRWING]() {
					goto l211
				}
				depth--
				add(ruleConstMap, position212)
			}
			return true
		l211:
			position, tokenIndex, depth = position211, tokenIndex211, depth211
			return false
		},
		/* 35 EscapeLiteralChar <- <('\\' ('"' / '\''))> */
		func() bool {
			position217, tokenIndex217, depth217 := position, tokenIndex, depth
			{
				position218 := position
				depth++
				if buffer[position] != rune('\\') {
					goto l217
				}
				position++
				{
					position219, tokenIndex219, depth219 := position, tokenIndex, depth
					if buffer[position] != rune('"') {
						goto l220
					}
					position++
					goto l219
				l220:
					position, tokenIndex, depth = position219, tokenIndex219, depth219
					if buffer[position] != rune('\'') {
						goto l217
					}
					position++
				}
			l219:
				depth--
				add(ruleEscapeLiteralChar, position218)
			}
			return true
		l217:
			position, tokenIndex, depth = position217, tokenIndex217, depth217
			return false
		},
		/* 36 Literal <- <(('"' <(EscapeLiteralChar / (!'"' .))*> '"' Skip) / ('\'' <(EscapeLiteralChar / (!'\'' .))*> '\'' Skip))> */
		func() bool {
			position221, tokenIndex221, depth221 := position, tokenIndex, depth
			{
				position222 := position
				depth++
				{
					position223, tokenIndex223, depth223 := position, tokenIndex, depth
					if buffer[position] != rune('"') {
						goto l224
					}
					position++
					{
						position225 := position
						depth++
					l226:
						{
							position227, tokenIndex227, depth227 := position, tokenIndex, depth
							{
								position228, tokenIndex228, depth228 := position, tokenIndex, depth
								if !_rules[ruleEscapeLiteralChar]() {
									goto l229
								}
								goto l228
							l229:
								position, tokenIndex, depth = position228, tokenIndex228, depth228
								{
									position230, tokenIndex230, depth230 := position, tokenIndex, depth
									if buffer[position] != rune('"') {
										goto l230
									}
									position++
									goto l227
								l230:
									position, tokenIndex, depth = position230, tokenIndex230, depth230
								}
								if !matchDot() {
									goto l227
								}
							}
						l228:
							goto l226
						l227:
							position, tokenIndex, depth = position227, tokenIndex227, depth227
						}
						depth--
						add(rulePegText, position225)
					}
					if buffer[position] != rune('"') {
						goto l224
					}
					position++
					if !_rules[ruleSkip]() {
						goto l224
					}
					goto l223
				l224:
					position, tokenIndex, depth = position223, tokenIndex223, depth223
					if buffer[position] != rune('\'') {
						goto l221
					}
					position++
					{
						position231 := position
						depth++
					l232:
						{
							position233, tokenIndex233, depth233 := position, tokenIndex, depth
							{
								position234, tokenIndex234, depth234 := position, tokenIndex, depth
								if !_rules[ruleEscapeLiteralChar]() {
									goto l235
								}
								goto l234
							l235:
								position, tokenIndex, depth = position234, tokenIndex234, depth234
								{
									position236, tokenIndex236, depth236 := position, tokenIndex, depth
									if buffer[position] != rune('\'') {
										goto l236
									}
									position++
									goto l233
								l236:
									position, tokenIndex, depth = position236, tokenIndex236, depth236
								}
								if !matchDot() {
									goto l233
								}
							}
						l234:
							goto l232
						l233:
							position, tokenIndex, depth = position233, tokenIndex233, depth233
						}
						depth--
						add(rulePegText, position231)
					}
					if buffer[position] != rune('\'') {
						goto l221
					}
					position++
					if !_rules[ruleSkip]() {
						goto l221
					}
				}
			l223:
				depth--
				add(ruleLiteral, position222)
			}
			return true
		l221:
			position, tokenIndex, depth = position221, tokenIndex221, depth221
			return false
		},
		/* 37 Identifier <- <(<(Letter (Letter / Digit / '.')*)> Skip)> */
		func() bool {
			position237, tokenIndex237, depth237 := position, tokenIndex, depth
			{
				position238 := position
				depth++
				{
					position239 := position
					depth++
					if !_rules[ruleLetter]() {
						goto l237
					}
				l240:
					{
						position241, tokenIndex241, depth241 := position, tokenIndex, depth
						{
							position242, tokenIndex242, depth242 := position, tokenIndex, depth
							if !_rules[ruleLetter]() {
								goto l243
							}
							goto l242
						l243:
							position, tokenIndex, depth = position242, tokenIndex242, depth242
							if !_rules[ruleDigit]() {
								goto l244
							}
							goto l242
						l244:
							position, tokenIndex, depth = position242, tokenIndex242, depth242
							if buffer[position] != rune('.') {
								goto l241
							}
							position++
						}
					l242:
						goto l240
					l241:
						position, tokenIndex, depth = position241, tokenIndex241, depth241
					}
					depth--
					add(rulePegText, position239)
				}
				if !_rules[ruleSkip]() {
					goto l237
				}
				depth--
				add(ruleIdentifier, position238)
			}
			return true
		l237:
			position, tokenIndex, depth = position237, tokenIndex237, depth237
			return false
		},
		/* 38 ListSeparator <- <((',' / ';') Skip)> */
		func() bool {
			position245, tokenIndex245, depth245 := position, tokenIndex, depth
			{
				position246 := position
				depth++
				{
					position247, tokenIndex247, depth247 := position, tokenIndex, depth
					if buffer[position] != rune(',') {
						goto l248
					}
					position++
					goto l247
				l248:
					position, tokenIndex, depth = position247, tokenIndex247, depth247
					if buffer[position] != rune(';') {
						goto l245
					}
					position++
				}
			l247:
				if !_rules[ruleSkip]() {
					goto l245
				}
				depth--
				add(ruleListSeparator, position246)
			}
			return true
		l245:
			position, tokenIndex, depth = position245, tokenIndex245, depth245
			return false
		},
		/* 39 Letter <- <([A-Z] / [a-z] / '_')> */
		func() bool {
			position249, tokenIndex249, depth249 := position, tokenIndex, depth
			{
				position250 := position
				depth++
				{
					position251, tokenIndex251, depth251 := position, tokenIndex, depth
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l252
					}
					position++
					goto l251
				l252:
					position, tokenIndex, depth = position251, tokenIndex251, depth251
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l253
					}
					position++
					goto l251
				l253:
					position, tokenIndex, depth = position251, tokenIndex251, depth251
					if buffer[position] != rune('_') {
						goto l249
					}
					position++
				}
			l251:
				depth--
				add(ruleLetter, position250)
			}
			return true
		l249:
			position, tokenIndex, depth = position249, tokenIndex249, depth249
			return false
		},
		/* 40 LetterOrDigit <- <([a-z] / [A-Z] / [0-9] / ('_' / '$'))> */
		func() bool {
			position254, tokenIndex254, depth254 := position, tokenIndex, depth
			{
				position255 := position
				depth++
				{
					position256, tokenIndex256, depth256 := position, tokenIndex, depth
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l257
					}
					position++
					goto l256
				l257:
					position, tokenIndex, depth = position256, tokenIndex256, depth256
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l258
					}
					position++
					goto l256
				l258:
					position, tokenIndex, depth = position256, tokenIndex256, depth256
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l259
					}
					position++
					goto l256
				l259:
					position, tokenIndex, depth = position256, tokenIndex256, depth256
					{
						position260, tokenIndex260, depth260 := position, tokenIndex, depth
						if buffer[position] != rune('_') {
							goto l261
						}
						position++
						goto l260
					l261:
						position, tokenIndex, depth = position260, tokenIndex260, depth260
						if buffer[position] != rune('$') {
							goto l254
						}
						position++
					}
				l260:
				}
			l256:
				depth--
				add(ruleLetterOrDigit, position255)
			}
			return true
		l254:
			position, tokenIndex, depth = position254, tokenIndex254, depth254
			return false
		},
		/* 41 Digit <- <[0-9]> */
		func() bool {
			position262, tokenIndex262, depth262 := position, tokenIndex, depth
			{
				position263 := position
				depth++
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l262
				}
				position++
				depth--
				add(ruleDigit, position263)
			}
			return true
		l262:
			position, tokenIndex, depth = position262, tokenIndex262, depth262
			return false
		},
		/* 42 Skip <- <(Space / LongComment / LineComment / UnixComment)*> */
		func() bool {
			{
				position265 := position
				depth++
			l266:
				{
					position267, tokenIndex267, depth267 := position, tokenIndex, depth
					{
						position268, tokenIndex268, depth268 := position, tokenIndex, depth
						if !_rules[ruleSpace]() {
							goto l269
						}
						goto l268
					l269:
						position, tokenIndex, depth = position268, tokenIndex268, depth268
						if !_rules[ruleLongComment]() {
							goto l270
						}
						goto l268
					l270:
						position, tokenIndex, depth = position268, tokenIndex268, depth268
						if !_rules[ruleLineComment]() {
							goto l271
						}
						goto l268
					l271:
						position, tokenIndex, depth = position268, tokenIndex268, depth268
						if !_rules[ruleUnixComment]() {
							goto l267
						}
					}
				l268:
					goto l266
				l267:
					position, tokenIndex, depth = position267, tokenIndex267, depth267
				}
				depth--
				add(ruleSkip, position265)
			}
			return true
		},
		/* 43 Space <- <(' ' / '\t' / '\r' / '\n')+> */
		func() bool {
			position272, tokenIndex272, depth272 := position, tokenIndex, depth
			{
				position273 := position
				depth++
				{
					position276, tokenIndex276, depth276 := position, tokenIndex, depth
					if buffer[position] != rune(' ') {
						goto l277
					}
					position++
					goto l276
				l277:
					position, tokenIndex, depth = position276, tokenIndex276, depth276
					if buffer[position] != rune('\t') {
						goto l278
					}
					position++
					goto l276
				l278:
					position, tokenIndex, depth = position276, tokenIndex276, depth276
					if buffer[position] != rune('\r') {
						goto l279
					}
					position++
					goto l276
				l279:
					position, tokenIndex, depth = position276, tokenIndex276, depth276
					if buffer[position] != rune('\n') {
						goto l272
					}
					position++
				}
			l276:
			l274:
				{
					position275, tokenIndex275, depth275 := position, tokenIndex, depth
					{
						position280, tokenIndex280, depth280 := position, tokenIndex, depth
						if buffer[position] != rune(' ') {
							goto l281
						}
						position++
						goto l280
					l281:
						position, tokenIndex, depth = position280, tokenIndex280, depth280
						if buffer[position] != rune('\t') {
							goto l282
						}
						position++
						goto l280
					l282:
						position, tokenIndex, depth = position280, tokenIndex280, depth280
						if buffer[position] != rune('\r') {
							goto l283
						}
						position++
						goto l280
					l283:
						position, tokenIndex, depth = position280, tokenIndex280, depth280
						if buffer[position] != rune('\n') {
							goto l275
						}
						position++
					}
				l280:
					goto l274
				l275:
					position, tokenIndex, depth = position275, tokenIndex275, depth275
				}
				depth--
				add(ruleSpace, position273)
			}
			return true
		l272:
			position, tokenIndex, depth = position272, tokenIndex272, depth272
			return false
		},
		/* 44 LongComment <- <('/' '*' (!('*' '/') .)* ('*' '/'))> */
		func() bool {
			position284, tokenIndex284, depth284 := position, tokenIndex, depth
			{
				position285 := position
				depth++
				if buffer[position] != rune('/') {
					goto l284
				}
				position++
				if buffer[position] != rune('*') {
					goto l284
				}
				position++
			l286:
				{
					position287, tokenIndex287, depth287 := position, tokenIndex, depth
					{
						position288, tokenIndex288, depth288 := position, tokenIndex, depth
						if buffer[position] != rune('*') {
							goto l288
						}
						position++
						if buffer[position] != rune('/') {
							goto l288
						}
						position++
						goto l287
					l288:
						position, tokenIndex, depth = position288, tokenIndex288, depth288
					}
					if !matchDot() {
						goto l287
					}
					goto l286
				l287:
					position, tokenIndex, depth = position287, tokenIndex287, depth287
				}
				if buffer[position] != rune('*') {
					goto l284
				}
				position++
				if buffer[position] != rune('/') {
					goto l284
				}
				position++
				depth--
				add(ruleLongComment, position285)
			}
			return true
		l284:
			position, tokenIndex, depth = position284, tokenIndex284, depth284
			return false
		},
		/* 45 LineComment <- <('/' '/' (!('\r' / '\n') .)*)> */
		func() bool {
			position289, tokenIndex289, depth289 := position, tokenIndex, depth
			{
				position290 := position
				depth++
				if buffer[position] != rune('/') {
					goto l289
				}
				position++
				if buffer[position] != rune('/') {
					goto l289
				}
				position++
			l291:
				{
					position292, tokenIndex292, depth292 := position, tokenIndex, depth
					{
						position293, tokenIndex293, depth293 := position, tokenIndex, depth
						{
							position294, tokenIndex294, depth294 := position, tokenIndex, depth
							if buffer[position] != rune('\r') {
								goto l295
							}
							position++
							goto l294
						l295:
							position, tokenIndex, depth = position294, tokenIndex294, depth294
							if buffer[position] != rune('\n') {
								goto l293
							}
							position++
						}
					l294:
						goto l292
					l293:
						position, tokenIndex, depth = position293, tokenIndex293, depth293
					}
					if !matchDot() {
						goto l292
					}
					goto l291
				l292:
					position, tokenIndex, depth = position292, tokenIndex292, depth292
				}
				depth--
				add(ruleLineComment, position290)
			}
			return true
		l289:
			position, tokenIndex, depth = position289, tokenIndex289, depth289
			return false
		},
		/* 46 UnixComment <- <('#' (!('\r' / '\n') .)*)> */
		func() bool {
			position296, tokenIndex296, depth296 := position, tokenIndex, depth
			{
				position297 := position
				depth++
				if buffer[position] != rune('#') {
					goto l296
				}
				position++
			l298:
				{
					position299, tokenIndex299, depth299 := position, tokenIndex, depth
					{
						position300, tokenIndex300, depth300 := position, tokenIndex, depth
						{
							position301, tokenIndex301, depth301 := position, tokenIndex, depth
							if buffer[position] != rune('\r') {
								goto l302
							}
							position++
							goto l301
						l302:
							position, tokenIndex, depth = position301, tokenIndex301, depth301
							if buffer[position] != rune('\n') {
								goto l300
							}
							position++
						}
					l301:
						goto l299
					l300:
						position, tokenIndex, depth = position300, tokenIndex300, depth300
					}
					if !matchDot() {
						goto l299
					}
					goto l298
				l299:
					position, tokenIndex, depth = position299, tokenIndex299, depth299
				}
				depth--
				add(ruleUnixComment, position297)
			}
			return true
		l296:
			position, tokenIndex, depth = position296, tokenIndex296, depth296
			return false
		},
		/* 47 BOOL <- <(<('b' 'o' 'o' 'l')> !LetterOrDigit Skip)> */
		func() bool {
			position303, tokenIndex303, depth303 := position, tokenIndex, depth
			{
				position304 := position
				depth++
				{
					position305 := position
					depth++
					if buffer[position] != rune('b') {
						goto l303
					}
					position++
					if buffer[position] != rune('o') {
						goto l303
					}
					position++
					if buffer[position] != rune('o') {
						goto l303
					}
					position++
					if buffer[position] != rune('l') {
						goto l303
					}
					position++
					depth--
					add(rulePegText, position305)
				}
				{
					position306, tokenIndex306, depth306 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l306
					}
					goto l303
				l306:
					position, tokenIndex, depth = position306, tokenIndex306, depth306
				}
				if !_rules[ruleSkip]() {
					goto l303
				}
				depth--
				add(ruleBOOL, position304)
			}
			return true
		l303:
			position, tokenIndex, depth = position303, tokenIndex303, depth303
			return false
		},
		/* 48 BYTE <- <(<('b' 'y' 't' 'e')> !LetterOrDigit Skip)> */
		func() bool {
			position307, tokenIndex307, depth307 := position, tokenIndex, depth
			{
				position308 := position
				depth++
				{
					position309 := position
					depth++
					if buffer[position] != rune('b') {
						goto l307
					}
					position++
					if buffer[position] != rune('y') {
						goto l307
					}
					position++
					if buffer[position] != rune('t') {
						goto l307
					}
					position++
					if buffer[position] != rune('e') {
						goto l307
					}
					position++
					depth--
					add(rulePegText, position309)
				}
				{
					position310, tokenIndex310, depth310 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l310
					}
					goto l307
				l310:
					position, tokenIndex, depth = position310, tokenIndex310, depth310
				}
				if !_rules[ruleSkip]() {
					goto l307
				}
				depth--
				add(ruleBYTE, position308)
			}
			return true
		l307:
			position, tokenIndex, depth = position307, tokenIndex307, depth307
			return false
		},
		/* 49 I8 <- <(<('i' '8')> !LetterOrDigit Skip)> */
		func() bool {
			position311, tokenIndex311, depth311 := position, tokenIndex, depth
			{
				position312 := position
				depth++
				{
					position313 := position
					depth++
					if buffer[position] != rune('i') {
						goto l311
					}
					position++
					if buffer[position] != rune('8') {
						goto l311
					}
					position++
					depth--
					add(rulePegText, position313)
				}
				{
					position314, tokenIndex314, depth314 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l314
					}
					goto l311
				l314:
					position, tokenIndex, depth = position314, tokenIndex314, depth314
				}
				if !_rules[ruleSkip]() {
					goto l311
				}
				depth--
				add(ruleI8, position312)
			}
			return true
		l311:
			position, tokenIndex, depth = position311, tokenIndex311, depth311
			return false
		},
		/* 50 I16 <- <(<('i' '1' '6')> !LetterOrDigit Skip)> */
		func() bool {
			position315, tokenIndex315, depth315 := position, tokenIndex, depth
			{
				position316 := position
				depth++
				{
					position317 := position
					depth++
					if buffer[position] != rune('i') {
						goto l315
					}
					position++
					if buffer[position] != rune('1') {
						goto l315
					}
					position++
					if buffer[position] != rune('6') {
						goto l315
					}
					position++
					depth--
					add(rulePegText, position317)
				}
				{
					position318, tokenIndex318, depth318 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l318
					}
					goto l315
				l318:
					position, tokenIndex, depth = position318, tokenIndex318, depth318
				}
				if !_rules[ruleSkip]() {
					goto l315
				}
				depth--
				add(ruleI16, position316)
			}
			return true
		l315:
			position, tokenIndex, depth = position315, tokenIndex315, depth315
			return false
		},
		/* 51 I32 <- <(<('i' '3' '2')> !LetterOrDigit Skip)> */
		func() bool {
			position319, tokenIndex319, depth319 := position, tokenIndex, depth
			{
				position320 := position
				depth++
				{
					position321 := position
					depth++
					if buffer[position] != rune('i') {
						goto l319
					}
					position++
					if buffer[position] != rune('3') {
						goto l319
					}
					position++
					if buffer[position] != rune('2') {
						goto l319
					}
					position++
					depth--
					add(rulePegText, position321)
				}
				{
					position322, tokenIndex322, depth322 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l322
					}
					goto l319
				l322:
					position, tokenIndex, depth = position322, tokenIndex322, depth322
				}
				if !_rules[ruleSkip]() {
					goto l319
				}
				depth--
				add(ruleI32, position320)
			}
			return true
		l319:
			position, tokenIndex, depth = position319, tokenIndex319, depth319
			return false
		},
		/* 52 I64 <- <(<('i' '6' '4')> !LetterOrDigit Skip)> */
		func() bool {
			position323, tokenIndex323, depth323 := position, tokenIndex, depth
			{
				position324 := position
				depth++
				{
					position325 := position
					depth++
					if buffer[position] != rune('i') {
						goto l323
					}
					position++
					if buffer[position] != rune('6') {
						goto l323
					}
					position++
					if buffer[position] != rune('4') {
						goto l323
					}
					position++
					depth--
					add(rulePegText, position325)
				}
				{
					position326, tokenIndex326, depth326 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l326
					}
					goto l323
				l326:
					position, tokenIndex, depth = position326, tokenIndex326, depth326
				}
				if !_rules[ruleSkip]() {
					goto l323
				}
				depth--
				add(ruleI64, position324)
			}
			return true
		l323:
			position, tokenIndex, depth = position323, tokenIndex323, depth323
			return false
		},
		/* 53 DOUBLE <- <(<('d' 'o' 'u' 'b' 'l' 'e')> !LetterOrDigit Skip)> */
		func() bool {
			position327, tokenIndex327, depth327 := position, tokenIndex, depth
			{
				position328 := position
				depth++
				{
					position329 := position
					depth++
					if buffer[position] != rune('d') {
						goto l327
					}
					position++
					if buffer[position] != rune('o') {
						goto l327
					}
					position++
					if buffer[position] != rune('u') {
						goto l327
					}
					position++
					if buffer[position] != rune('b') {
						goto l327
					}
					position++
					if buffer[position] != rune('l') {
						goto l327
					}
					position++
					if buffer[position] != rune('e') {
						goto l327
					}
					position++
					depth--
					add(rulePegText, position329)
				}
				{
					position330, tokenIndex330, depth330 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l330
					}
					goto l327
				l330:
					position, tokenIndex, depth = position330, tokenIndex330, depth330
				}
				if !_rules[ruleSkip]() {
					goto l327
				}
				depth--
				add(ruleDOUBLE, position328)
			}
			return true
		l327:
			position, tokenIndex, depth = position327, tokenIndex327, depth327
			return false
		},
		/* 54 STRING <- <(<('s' 't' 'r' 'i' 'n' 'g')> !LetterOrDigit Skip)> */
		func() bool {
			position331, tokenIndex331, depth331 := position, tokenIndex, depth
			{
				position332 := position
				depth++
				{
					position333 := position
					depth++
					if buffer[position] != rune('s') {
						goto l331
					}
					position++
					if buffer[position] != rune('t') {
						goto l331
					}
					position++
					if buffer[position] != rune('r') {
						goto l331
					}
					position++
					if buffer[position] != rune('i') {
						goto l331
					}
					position++
					if buffer[position] != rune('n') {
						goto l331
					}
					position++
					if buffer[position] != rune('g') {
						goto l331
					}
					position++
					depth--
					add(rulePegText, position333)
				}
				{
					position334, tokenIndex334, depth334 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l334
					}
					goto l331
				l334:
					position, tokenIndex, depth = position334, tokenIndex334, depth334
				}
				if !_rules[ruleSkip]() {
					goto l331
				}
				depth--
				add(ruleSTRING, position332)
			}
			return true
		l331:
			position, tokenIndex, depth = position331, tokenIndex331, depth331
			return false
		},
		/* 55 BINARY <- <(<('b' 'i' 'n' 'a' 'r' 'y')> !LetterOrDigit Skip)> */
		func() bool {
			position335, tokenIndex335, depth335 := position, tokenIndex, depth
			{
				position336 := position
				depth++
				{
					position337 := position
					depth++
					if buffer[position] != rune('b') {
						goto l335
					}
					position++
					if buffer[position] != rune('i') {
						goto l335
					}
					position++
					if buffer[position] != rune('n') {
						goto l335
					}
					position++
					if buffer[position] != rune('a') {
						goto l335
					}
					position++
					if buffer[position] != rune('r') {
						goto l335
					}
					position++
					if buffer[position] != rune('y') {
						goto l335
					}
					position++
					depth--
					add(rulePegText, position337)
				}
				{
					position338, tokenIndex338, depth338 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l338
					}
					goto l335
				l338:
					position, tokenIndex, depth = position338, tokenIndex338, depth338
				}
				if !_rules[ruleSkip]() {
					goto l335
				}
				depth--
				add(ruleBINARY, position336)
			}
			return true
		l335:
			position, tokenIndex, depth = position335, tokenIndex335, depth335
			return false
		},
		/* 56 CONST <- <('c' 'o' 'n' 's' 't' !LetterOrDigit Skip)> */
		func() bool {
			position339, tokenIndex339, depth339 := position, tokenIndex, depth
			{
				position340 := position
				depth++
				if buffer[position] != rune('c') {
					goto l339
				}
				position++
				if buffer[position] != rune('o') {
					goto l339
				}
				position++
				if buffer[position] != rune('n') {
					goto l339
				}
				position++
				if buffer[position] != rune('s') {
					goto l339
				}
				position++
				if buffer[position] != rune('t') {
					goto l339
				}
				position++
				{
					position341, tokenIndex341, depth341 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l341
					}
					goto l339
				l341:
					position, tokenIndex, depth = position341, tokenIndex341, depth341
				}
				if !_rules[ruleSkip]() {
					goto l339
				}
				depth--
				add(ruleCONST, position340)
			}
			return true
		l339:
			position, tokenIndex, depth = position339, tokenIndex339, depth339
			return false
		},
		/* 57 ONEWAY <- <('o' 'n' 'e' 'w' 'a' 'y' !LetterOrDigit Skip)> */
		func() bool {
			position342, tokenIndex342, depth342 := position, tokenIndex, depth
			{
				position343 := position
				depth++
				if buffer[position] != rune('o') {
					goto l342
				}
				position++
				if buffer[position] != rune('n') {
					goto l342
				}
				position++
				if buffer[position] != rune('e') {
					goto l342
				}
				position++
				if buffer[position] != rune('w') {
					goto l342
				}
				position++
				if buffer[position] != rune('a') {
					goto l342
				}
				position++
				if buffer[position] != rune('y') {
					goto l342
				}
				position++
				{
					position344, tokenIndex344, depth344 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l344
					}
					goto l342
				l344:
					position, tokenIndex, depth = position344, tokenIndex344, depth344
				}
				if !_rules[ruleSkip]() {
					goto l342
				}
				depth--
				add(ruleONEWAY, position343)
			}
			return true
		l342:
			position, tokenIndex, depth = position342, tokenIndex342, depth342
			return false
		},
		/* 58 TYPEDEF <- <('t' 'y' 'p' 'e' 'd' 'e' 'f' !LetterOrDigit Skip)> */
		func() bool {
			position345, tokenIndex345, depth345 := position, tokenIndex, depth
			{
				position346 := position
				depth++
				if buffer[position] != rune('t') {
					goto l345
				}
				position++
				if buffer[position] != rune('y') {
					goto l345
				}
				position++
				if buffer[position] != rune('p') {
					goto l345
				}
				position++
				if buffer[position] != rune('e') {
					goto l345
				}
				position++
				if buffer[position] != rune('d') {
					goto l345
				}
				position++
				if buffer[position] != rune('e') {
					goto l345
				}
				position++
				if buffer[position] != rune('f') {
					goto l345
				}
				position++
				{
					position347, tokenIndex347, depth347 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l347
					}
					goto l345
				l347:
					position, tokenIndex, depth = position347, tokenIndex347, depth347
				}
				if !_rules[ruleSkip]() {
					goto l345
				}
				depth--
				add(ruleTYPEDEF, position346)
			}
			return true
		l345:
			position, tokenIndex, depth = position345, tokenIndex345, depth345
			return false
		},
		/* 59 MAP <- <('m' 'a' 'p' !LetterOrDigit Skip)> */
		func() bool {
			position348, tokenIndex348, depth348 := position, tokenIndex, depth
			{
				position349 := position
				depth++
				if buffer[position] != rune('m') {
					goto l348
				}
				position++
				if buffer[position] != rune('a') {
					goto l348
				}
				position++
				if buffer[position] != rune('p') {
					goto l348
				}
				position++
				{
					position350, tokenIndex350, depth350 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l350
					}
					goto l348
				l350:
					position, tokenIndex, depth = position350, tokenIndex350, depth350
				}
				if !_rules[ruleSkip]() {
					goto l348
				}
				depth--
				add(ruleMAP, position349)
			}
			return true
		l348:
			position, tokenIndex, depth = position348, tokenIndex348, depth348
			return false
		},
		/* 60 SET <- <('s' 'e' 't' !LetterOrDigit Skip)> */
		func() bool {
			position351, tokenIndex351, depth351 := position, tokenIndex, depth
			{
				position352 := position
				depth++
				if buffer[position] != rune('s') {
					goto l351
				}
				position++
				if buffer[position] != rune('e') {
					goto l351
				}
				position++
				if buffer[position] != rune('t') {
					goto l351
				}
				position++
				{
					position353, tokenIndex353, depth353 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l353
					}
					goto l351
				l353:
					position, tokenIndex, depth = position353, tokenIndex353, depth353
				}
				if !_rules[ruleSkip]() {
					goto l351
				}
				depth--
				add(ruleSET, position352)
			}
			return true
		l351:
			position, tokenIndex, depth = position351, tokenIndex351, depth351
			return false
		},
		/* 61 LIST <- <('l' 'i' 's' 't' !LetterOrDigit Skip)> */
		func() bool {
			position354, tokenIndex354, depth354 := position, tokenIndex, depth
			{
				position355 := position
				depth++
				if buffer[position] != rune('l') {
					goto l354
				}
				position++
				if buffer[position] != rune('i') {
					goto l354
				}
				position++
				if buffer[position] != rune('s') {
					goto l354
				}
				position++
				if buffer[position] != rune('t') {
					goto l354
				}
				position++
				{
					position356, tokenIndex356, depth356 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l356
					}
					goto l354
				l356:
					position, tokenIndex, depth = position356, tokenIndex356, depth356
				}
				if !_rules[ruleSkip]() {
					goto l354
				}
				depth--
				add(ruleLIST, position355)
			}
			return true
		l354:
			position, tokenIndex, depth = position354, tokenIndex354, depth354
			return false
		},
		/* 62 VOID <- <('v' 'o' 'i' 'd' !LetterOrDigit Skip)> */
		func() bool {
			position357, tokenIndex357, depth357 := position, tokenIndex, depth
			{
				position358 := position
				depth++
				if buffer[position] != rune('v') {
					goto l357
				}
				position++
				if buffer[position] != rune('o') {
					goto l357
				}
				position++
				if buffer[position] != rune('i') {
					goto l357
				}
				position++
				if buffer[position] != rune('d') {
					goto l357
				}
				position++
				{
					position359, tokenIndex359, depth359 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l359
					}
					goto l357
				l359:
					position, tokenIndex, depth = position359, tokenIndex359, depth359
				}
				if !_rules[ruleSkip]() {
					goto l357
				}
				depth--
				add(ruleVOID, position358)
			}
			return true
		l357:
			position, tokenIndex, depth = position357, tokenIndex357, depth357
			return false
		},
		/* 63 THROWS <- <('t' 'h' 'r' 'o' 'w' 's' !LetterOrDigit Skip)> */
		func() bool {
			position360, tokenIndex360, depth360 := position, tokenIndex, depth
			{
				position361 := position
				depth++
				if buffer[position] != rune('t') {
					goto l360
				}
				position++
				if buffer[position] != rune('h') {
					goto l360
				}
				position++
				if buffer[position] != rune('r') {
					goto l360
				}
				position++
				if buffer[position] != rune('o') {
					goto l360
				}
				position++
				if buffer[position] != rune('w') {
					goto l360
				}
				position++
				if buffer[position] != rune('s') {
					goto l360
				}
				position++
				{
					position362, tokenIndex362, depth362 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l362
					}
					goto l360
				l362:
					position, tokenIndex, depth = position362, tokenIndex362, depth362
				}
				if !_rules[ruleSkip]() {
					goto l360
				}
				depth--
				add(ruleTHROWS, position361)
			}
			return true
		l360:
			position, tokenIndex, depth = position360, tokenIndex360, depth360
			return false
		},
		/* 64 EXCEPTION <- <('e' 'x' 'c' 'e' 'p' 't' 'i' 'o' 'n' !LetterOrDigit Skip)> */
		func() bool {
			position363, tokenIndex363, depth363 := position, tokenIndex, depth
			{
				position364 := position
				depth++
				if buffer[position] != rune('e') {
					goto l363
				}
				position++
				if buffer[position] != rune('x') {
					goto l363
				}
				position++
				if buffer[position] != rune('c') {
					goto l363
				}
				position++
				if buffer[position] != rune('e') {
					goto l363
				}
				position++
				if buffer[position] != rune('p') {
					goto l363
				}
				position++
				if buffer[position] != rune('t') {
					goto l363
				}
				position++
				if buffer[position] != rune('i') {
					goto l363
				}
				position++
				if buffer[position] != rune('o') {
					goto l363
				}
				position++
				if buffer[position] != rune('n') {
					goto l363
				}
				position++
				{
					position365, tokenIndex365, depth365 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l365
					}
					goto l363
				l365:
					position, tokenIndex, depth = position365, tokenIndex365, depth365
				}
				if !_rules[ruleSkip]() {
					goto l363
				}
				depth--
				add(ruleEXCEPTION, position364)
			}
			return true
		l363:
			position, tokenIndex, depth = position363, tokenIndex363, depth363
			return false
		},
		/* 65 EXTENDS <- <('e' 'x' 't' 'e' 'n' 'd' 's' !LetterOrDigit Skip)> */
		func() bool {
			position366, tokenIndex366, depth366 := position, tokenIndex, depth
			{
				position367 := position
				depth++
				if buffer[position] != rune('e') {
					goto l366
				}
				position++
				if buffer[position] != rune('x') {
					goto l366
				}
				position++
				if buffer[position] != rune('t') {
					goto l366
				}
				position++
				if buffer[position] != rune('e') {
					goto l366
				}
				position++
				if buffer[position] != rune('n') {
					goto l366
				}
				position++
				if buffer[position] != rune('d') {
					goto l366
				}
				position++
				if buffer[position] != rune('s') {
					goto l366
				}
				position++
				{
					position368, tokenIndex368, depth368 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l368
					}
					goto l366
				l368:
					position, tokenIndex, depth = position368, tokenIndex368, depth368
				}
				if !_rules[ruleSkip]() {
					goto l366
				}
				depth--
				add(ruleEXTENDS, position367)
			}
			return true
		l366:
			position, tokenIndex, depth = position366, tokenIndex366, depth366
			return false
		},
		/* 66 SERVICE <- <('s' 'e' 'r' 'v' 'i' 'c' 'e' !LetterOrDigit Skip)> */
		func() bool {
			position369, tokenIndex369, depth369 := position, tokenIndex, depth
			{
				position370 := position
				depth++
				if buffer[position] != rune('s') {
					goto l369
				}
				position++
				if buffer[position] != rune('e') {
					goto l369
				}
				position++
				if buffer[position] != rune('r') {
					goto l369
				}
				position++
				if buffer[position] != rune('v') {
					goto l369
				}
				position++
				if buffer[position] != rune('i') {
					goto l369
				}
				position++
				if buffer[position] != rune('c') {
					goto l369
				}
				position++
				if buffer[position] != rune('e') {
					goto l369
				}
				position++
				{
					position371, tokenIndex371, depth371 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l371
					}
					goto l369
				l371:
					position, tokenIndex, depth = position371, tokenIndex371, depth371
				}
				if !_rules[ruleSkip]() {
					goto l369
				}
				depth--
				add(ruleSERVICE, position370)
			}
			return true
		l369:
			position, tokenIndex, depth = position369, tokenIndex369, depth369
			return false
		},
		/* 67 STRUCT <- <('s' 't' 'r' 'u' 'c' 't' !LetterOrDigit Skip)> */
		func() bool {
			position372, tokenIndex372, depth372 := position, tokenIndex, depth
			{
				position373 := position
				depth++
				if buffer[position] != rune('s') {
					goto l372
				}
				position++
				if buffer[position] != rune('t') {
					goto l372
				}
				position++
				if buffer[position] != rune('r') {
					goto l372
				}
				position++
				if buffer[position] != rune('u') {
					goto l372
				}
				position++
				if buffer[position] != rune('c') {
					goto l372
				}
				position++
				if buffer[position] != rune('t') {
					goto l372
				}
				position++
				{
					position374, tokenIndex374, depth374 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l374
					}
					goto l372
				l374:
					position, tokenIndex, depth = position374, tokenIndex374, depth374
				}
				if !_rules[ruleSkip]() {
					goto l372
				}
				depth--
				add(ruleSTRUCT, position373)
			}
			return true
		l372:
			position, tokenIndex, depth = position372, tokenIndex372, depth372
			return false
		},
		/* 68 UNION <- <('u' 'n' 'i' 'o' 'n' !LetterOrDigit Skip)> */
		func() bool {
			position375, tokenIndex375, depth375 := position, tokenIndex, depth
			{
				position376 := position
				depth++
				if buffer[position] != rune('u') {
					goto l375
				}
				position++
				if buffer[position] != rune('n') {
					goto l375
				}
				position++
				if buffer[position] != rune('i') {
					goto l375
				}
				position++
				if buffer[position] != rune('o') {
					goto l375
				}
				position++
				if buffer[position] != rune('n') {
					goto l375
				}
				position++
				{
					position377, tokenIndex377, depth377 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l377
					}
					goto l375
				l377:
					position, tokenIndex, depth = position377, tokenIndex377, depth377
				}
				if !_rules[ruleSkip]() {
					goto l375
				}
				depth--
				add(ruleUNION, position376)
			}
			return true
		l375:
			position, tokenIndex, depth = position375, tokenIndex375, depth375
			return false
		},
		/* 69 ENUM <- <('e' 'n' 'u' 'm' !LetterOrDigit Skip)> */
		func() bool {
			position378, tokenIndex378, depth378 := position, tokenIndex, depth
			{
				position379 := position
				depth++
				if buffer[position] != rune('e') {
					goto l378
				}
				position++
				if buffer[position] != rune('n') {
					goto l378
				}
				position++
				if buffer[position] != rune('u') {
					goto l378
				}
				position++
				if buffer[position] != rune('m') {
					goto l378
				}
				position++
				{
					position380, tokenIndex380, depth380 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l380
					}
					goto l378
				l380:
					position, tokenIndex, depth = position380, tokenIndex380, depth380
				}
				if !_rules[ruleSkip]() {
					goto l378
				}
				depth--
				add(ruleENUM, position379)
			}
			return true
		l378:
			position, tokenIndex, depth = position378, tokenIndex378, depth378
			return false
		},
		/* 70 INCLUDE <- <('i' 'n' 'c' 'l' 'u' 'd' 'e' !LetterOrDigit Skip)> */
		func() bool {
			position381, tokenIndex381, depth381 := position, tokenIndex, depth
			{
				position382 := position
				depth++
				if buffer[position] != rune('i') {
					goto l381
				}
				position++
				if buffer[position] != rune('n') {
					goto l381
				}
				position++
				if buffer[position] != rune('c') {
					goto l381
				}
				position++
				if buffer[position] != rune('l') {
					goto l381
				}
				position++
				if buffer[position] != rune('u') {
					goto l381
				}
				position++
				if buffer[position] != rune('d') {
					goto l381
				}
				position++
				if buffer[position] != rune('e') {
					goto l381
				}
				position++
				{
					position383, tokenIndex383, depth383 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l383
					}
					goto l381
				l383:
					position, tokenIndex, depth = position383, tokenIndex383, depth383
				}
				if !_rules[ruleSkip]() {
					goto l381
				}
				depth--
				add(ruleINCLUDE, position382)
			}
			return true
		l381:
			position, tokenIndex, depth = position381, tokenIndex381, depth381
			return false
		},
		/* 71 CPPINCLUDE <- <('c' 'p' 'p' '_' 'i' 'n' 'c' 'l' 'u' 'd' 'e' !LetterOrDigit Skip)> */
		func() bool {
			position384, tokenIndex384, depth384 := position, tokenIndex, depth
			{
				position385 := position
				depth++
				if buffer[position] != rune('c') {
					goto l384
				}
				position++
				if buffer[position] != rune('p') {
					goto l384
				}
				position++
				if buffer[position] != rune('p') {
					goto l384
				}
				position++
				if buffer[position] != rune('_') {
					goto l384
				}
				position++
				if buffer[position] != rune('i') {
					goto l384
				}
				position++
				if buffer[position] != rune('n') {
					goto l384
				}
				position++
				if buffer[position] != rune('c') {
					goto l384
				}
				position++
				if buffer[position] != rune('l') {
					goto l384
				}
				position++
				if buffer[position] != rune('u') {
					goto l384
				}
				position++
				if buffer[position] != rune('d') {
					goto l384
				}
				position++
				if buffer[position] != rune('e') {
					goto l384
				}
				position++
				{
					position386, tokenIndex386, depth386 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l386
					}
					goto l384
				l386:
					position, tokenIndex, depth = position386, tokenIndex386, depth386
				}
				if !_rules[ruleSkip]() {
					goto l384
				}
				depth--
				add(ruleCPPINCLUDE, position385)
			}
			return true
		l384:
			position, tokenIndex, depth = position384, tokenIndex384, depth384
			return false
		},
		/* 72 NAMESPACE <- <('n' 'a' 'm' 'e' 's' 'p' 'a' 'c' 'e' !LetterOrDigit Skip)> */
		func() bool {
			position387, tokenIndex387, depth387 := position, tokenIndex, depth
			{
				position388 := position
				depth++
				if buffer[position] != rune('n') {
					goto l387
				}
				position++
				if buffer[position] != rune('a') {
					goto l387
				}
				position++
				if buffer[position] != rune('m') {
					goto l387
				}
				position++
				if buffer[position] != rune('e') {
					goto l387
				}
				position++
				if buffer[position] != rune('s') {
					goto l387
				}
				position++
				if buffer[position] != rune('p') {
					goto l387
				}
				position++
				if buffer[position] != rune('a') {
					goto l387
				}
				position++
				if buffer[position] != rune('c') {
					goto l387
				}
				position++
				if buffer[position] != rune('e') {
					goto l387
				}
				position++
				{
					position389, tokenIndex389, depth389 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l389
					}
					goto l387
				l389:
					position, tokenIndex, depth = position389, tokenIndex389, depth389
				}
				if !_rules[ruleSkip]() {
					goto l387
				}
				depth--
				add(ruleNAMESPACE, position388)
			}
			return true
		l387:
			position, tokenIndex, depth = position387, tokenIndex387, depth387
			return false
		},
		/* 73 CPPTYPE <- <('c' 'p' 'p' '_' 't' 'y' 'p' 'e' !LetterOrDigit Skip)> */
		func() bool {
			position390, tokenIndex390, depth390 := position, tokenIndex, depth
			{
				position391 := position
				depth++
				if buffer[position] != rune('c') {
					goto l390
				}
				position++
				if buffer[position] != rune('p') {
					goto l390
				}
				position++
				if buffer[position] != rune('p') {
					goto l390
				}
				position++
				if buffer[position] != rune('_') {
					goto l390
				}
				position++
				if buffer[position] != rune('t') {
					goto l390
				}
				position++
				if buffer[position] != rune('y') {
					goto l390
				}
				position++
				if buffer[position] != rune('p') {
					goto l390
				}
				position++
				if buffer[position] != rune('e') {
					goto l390
				}
				position++
				{
					position392, tokenIndex392, depth392 := position, tokenIndex, depth
					if !_rules[ruleLetterOrDigit]() {
						goto l392
					}
					goto l390
				l392:
					position, tokenIndex, depth = position392, tokenIndex392, depth392
				}
				if !_rules[ruleSkip]() {
					goto l390
				}
				depth--
				add(ruleCPPTYPE, position391)
			}
			return true
		l390:
			position, tokenIndex, depth = position390, tokenIndex390, depth390
			return false
		},
		/* 74 LBRK <- <('[' Skip)> */
		func() bool {
			position393, tokenIndex393, depth393 := position, tokenIndex, depth
			{
				position394 := position
				depth++
				if buffer[position] != rune('[') {
					goto l393
				}
				position++
				if !_rules[ruleSkip]() {
					goto l393
				}
				depth--
				add(ruleLBRK, position394)
			}
			return true
		l393:
			position, tokenIndex, depth = position393, tokenIndex393, depth393
			return false
		},
		/* 75 RBRK <- <(']' Skip)> */
		func() bool {
			position395, tokenIndex395, depth395 := position, tokenIndex, depth
			{
				position396 := position
				depth++
				if buffer[position] != rune(']') {
					goto l395
				}
				position++
				if !_rules[ruleSkip]() {
					goto l395
				}
				depth--
				add(ruleRBRK, position396)
			}
			return true
		l395:
			position, tokenIndex, depth = position395, tokenIndex395, depth395
			return false
		},
		/* 76 LWING <- <('{' Skip)> */
		func() bool {
			position397, tokenIndex397, depth397 := position, tokenIndex, depth
			{
				position398 := position
				depth++
				if buffer[position] != rune('{') {
					goto l397
				}
				position++
				if !_rules[ruleSkip]() {
					goto l397
				}
				depth--
				add(ruleLWING, position398)
			}
			return true
		l397:
			position, tokenIndex, depth = position397, tokenIndex397, depth397
			return false
		},
		/* 77 RWING <- <('}' Skip)> */
		func() bool {
			position399, tokenIndex399, depth399 := position, tokenIndex, depth
			{
				position400 := position
				depth++
				if buffer[position] != rune('}') {
					goto l399
				}
				position++
				if !_rules[ruleSkip]() {
					goto l399
				}
				depth--
				add(ruleRWING, position400)
			}
			return true
		l399:
			position, tokenIndex, depth = position399, tokenIndex399, depth399
			return false
		},
		/* 78 EQUAL <- <('=' Skip)> */
		func() bool {
			position401, tokenIndex401, depth401 := position, tokenIndex, depth
			{
				position402 := position
				depth++
				if buffer[position] != rune('=') {
					goto l401
				}
				position++
				if !_rules[ruleSkip]() {
					goto l401
				}
				depth--
				add(ruleEQUAL, position402)
			}
			return true
		l401:
			position, tokenIndex, depth = position401, tokenIndex401, depth401
			return false
		},
		/* 79 LPOINT <- <('<' Skip)> */
		func() bool {
			position403, tokenIndex403, depth403 := position, tokenIndex, depth
			{
				position404 := position
				depth++
				if buffer[position] != rune('<') {
					goto l403
				}
				position++
				if !_rules[ruleSkip]() {
					goto l403
				}
				depth--
				add(ruleLPOINT, position404)
			}
			return true
		l403:
			position, tokenIndex, depth = position403, tokenIndex403, depth403
			return false
		},
		/* 80 RPOINT <- <('>' Skip)> */
		func() bool {
			position405, tokenIndex405, depth405 := position, tokenIndex, depth
			{
				position406 := position
				depth++
				if buffer[position] != rune('>') {
					goto l405
				}
				position++
				if !_rules[ruleSkip]() {
					goto l405
				}
				depth--
				add(ruleRPOINT, position406)
			}
			return true
		l405:
			position, tokenIndex, depth = position405, tokenIndex405, depth405
			return false
		},
		/* 81 COMMA <- <(',' Skip)> */
		func() bool {
			position407, tokenIndex407, depth407 := position, tokenIndex, depth
			{
				position408 := position
				depth++
				if buffer[position] != rune(',') {
					goto l407
				}
				position++
				if !_rules[ruleSkip]() {
					goto l407
				}
				depth--
				add(ruleCOMMA, position408)
			}
			return true
		l407:
			position, tokenIndex, depth = position407, tokenIndex407, depth407
			return false
		},
		/* 82 LPAR <- <('(' Skip)> */
		func() bool {
			position409, tokenIndex409, depth409 := position, tokenIndex, depth
			{
				position410 := position
				depth++
				if buffer[position] != rune('(') {
					goto l409
				}
				position++
				if !_rules[ruleSkip]() {
					goto l409
				}
				depth--
				add(ruleLPAR, position410)
			}
			return true
		l409:
			position, tokenIndex, depth = position409, tokenIndex409, depth409
			return false
		},
		/* 83 RPAR <- <(')' Skip)> */
		func() bool {
			position411, tokenIndex411, depth411 := position, tokenIndex, depth
			{
				position412 := position
				depth++
				if buffer[position] != rune(')') {
					goto l411
				}
				position++
				if !_rules[ruleSkip]() {
					goto l411
				}
				depth--
				add(ruleRPAR, position412)
			}
			return true
		l411:
			position, tokenIndex, depth = position411, tokenIndex411, depth411
			return false
		},
		/* 84 COLON <- <(':' Skip)> */
		func() bool {
			position413, tokenIndex413, depth413 := position, tokenIndex, depth
			{
				position414 := position
				depth++
				if buffer[position] != rune(':') {
					goto l413
				}
				position++
				if !_rules[ruleSkip]() {
					goto l413
				}
				depth--
				add(ruleCOLON, position414)
			}
			return true
		l413:
			position, tokenIndex, depth = position413, tokenIndex413, depth413
			return false
		},
		nil,
	}
	p.rules = _rules
}
